1.外网接入流程：https://blog.csdn.net/yang75108/article/details/101268208
2.服务发现和负载均衡：https://blog.csdn.net/yang75108/article/details/101267444
3.pod虚拟机互通：https://blog.csdn.net/yang75108/article/details/101101384

注：每一层都是构建于前一层之上

第三层：外部网络接入（外部流量接入）
【NodePort、LoadBlancer、Ingress】
第二层：service网络（服务发现和负载均衡）
【Cluster IP + Port】
第一层：pod网络（pod虚拟机互通互联）
【Pord IP + Port】
第0层：Node节点网络（节点主机互通，一般不用管，都是通的）
【Node IP + Port】

一、第0层
第0层Node节点网络比较好理解，也就是保证K8s节点(物理或虚拟机)之间能够正常IP寻址和互通的网络

二、第一层（https://blog.csdn.net/yang75108/article/details/101101384）
1.Pod相当于是K8s云平台中的虚拟机，它是K8s的基本调度单位。Pod网络构建于Node节点网络之上，它又是上层Service网络的基础。
2.所谓Pod网络，就是能够保证K8s集群中的所有Pods(包括同一节点上的，也包括不同节点上的Pods)，能够相互做IP寻址和通信的网络。

3.流量：
host：eth0（nodeIP）——>docker0（nodeDockerIP）——>veth0（单个pod内的虚拟ip用于连接pod内的container和pause）

eth0是节点主机上的网卡，这个是支持该节点流量出入的设备，也是支持集群节点间IP寻址和互通的设备
docker0是一个虚拟网桥，可以简单理解为一个虚拟交换机，它是支持该节点上的Pod之间进行IP寻址和互通的设备
veth0则是单个Pod内的虚拟网卡，是支持该Pod内容器互通和对外访问的虚拟设备
（Pod1中还有一个比较特殊的叫pause的容器，这个容器运行的唯一目的是为Pod建立共享的veth0网络接口）

4.网络插件
flannel/weavenet：采用隧道封包技术
CNI(Container Network Interface)


总结：K8s的网络可以抽象成四层网络，第0层节点网络，第1层Pod网络，第2层Service网络，第3层外部接入网络。除了第0层，每一层都构建于上一层之上。
一个节点内的Pod网络依赖于虚拟网桥和虚拟网卡等linux虚拟设备，保证同一节点上的Pod之间可以正常IP寻址和互通。一个Pod内容器共享该Pod的网络栈，这个网络栈由pause容器创建。
不同节点间的Pod网络，可以采用路由方案实现，也可以采用覆盖网络方案。路由方案依赖于底层网络设备，但没有额外性能开销，覆盖网络方案不依赖于底层网络，但有额外封包解包开销。
CNI是一个Pod网络集成标准，简化K8s和不同Pod网络实现技术的集成。

三、第二层（https://blog.csdn.net/yang75108/article/details/101267444）

一个Service背后一般由多个Pods组成集群，这时候就引入了服务发现(Service Discovery)和负载均衡(Load Balancing)等问题
1.流量
k8s Cluster：pod（client）——>AccountService(提供访问pod集群的虚拟ip：clusterIP)——>podIPs（pod集群，pod1、pod2、pod3...）

服务发现：Account-Service提供统一的ClusterIP来解决服务发现问题，Client只需通过ClusterIP就可以访问Account-App的Pod集群，不需要关心集群中的具体Pod数量和PodIP，
即使是PodIP发生变化也会被ClusterIP所屏蔽。
注意，这里的ClusterIP实际是个虚拟IP，也称Virtual IP(VIP)

负载均衡：Account-Service抽象层具有负载均衡的能力，支持以不同策略去访问pod集群中的不同Pod实例，以实现负载分摊和HA高可用。
K8s中默认的负载均衡策略是RoundRobin，也可以定制其它复杂策略
