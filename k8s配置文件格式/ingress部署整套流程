参考链接：https://github.com/gjmzj/kubeasz

一、ingress详解

1.规划介绍
K8s集群对外暴露服务的方式目前只有三种：loadblancer、nodeport、ingress。前两种熟悉起来比较快，而且使用起来也比较方便，在此就不进行介绍了。
下面详细讲解下ingress这个服务，ingress由两部分组成：ingress controller和ingress服务。
其中ingress controller目前主要有两种：基于nginx服务的ingress controller和基于traefik的ingress controller。
由于对nginx比较熟悉，而且需要使用TCP负载，所以在此我们选择的是基于nginx服务的ingress controller。

2.参考社区
k8s社区提供的ingress，github地址如下：https://github.com/kubernetes/ingress-nginx
nginx社区提供的ingress，github地址如下：https://github.com/nginxinc/kubernetes-ingress

二、ingress的工作原理

ingress contronler通过与k8s的api进行交互，动态的去感知k8s集群中ingress服务规则的变化，然后读取它，并按照定义的ingress规则，转发到k8s集群中对应的service。
而这个ingress规则写明了哪个域名对应k8s集群中的哪个service，然后再根据ingress-controller中的nginx配置模板，生成一段对应的nginx配置。
然后再把该配置动态的写到ingress-controller的pod里，该ingress-controller的pod里面运行着一个nginx服务，控制器会把生成的nginx配置写入到nginx的配置文件中，然后reload一下，使其配置生效。
以此来达到域名分配置及动态更新的效果。

三、实操
3.1 拉取应用镜像
docker pull httpd:alpine
docker pull tomcat:alpine
拉取nginx-controller镜像如下：docker pull quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.21.0

3.2 创建namespace

3.2.1 #cat >yl-namespace.yaml << “EOF”
apiVersion: v1
kind: Namespace
metadata:
  name: yl-namespace
  labels:
    name: yl-namespace
 EOF
 
3.2.2 创建ns    
#kubectl apply -f yl-namespace.yml –record
namespace/yl-namespace created

3.2.3 查询创建的yl-namespace
#kubectl get ns
yl-namespace   Active 6s

3.3 创建service

3.3.1 #cat > yl-httpd-service.yml << “EOF”
apiVersion: v1
kind: Service
metadata:
  name: yl-httpd-svc
  namespace: yl-namespace
spec:
  type: NodePort
  ports:
  - name: http-port
    nodePort: 32080
    port: 80
    targetPort: 80
  selector:
    app: yl-httpd-dm

注：在yl-httpd-service.yml文件中，我们在yl-namespace这个ns中，定义一个名为yl-httpd-svc的Service，并且使用NodePort这个service类型，使用32080端口对外提供访问端口。
    同时这个yml文件中，我们也使用selector来选择后端的Deployment，在此我们选择的是yl-httpd-dm（对应后面的deploy名称）。

3.3.2 创建service
#kubectl apply -f yl-service.yaml
service/yl-httpd-svc created

3.3.3 查询创建的service
kubectl get service -n yl-namespace
yl-httpd-svc   NodePort   192.8.241.76   <none>        80:32080/TCP   13s
注：service分配的ip为192.8.241.76，此ip为k8s集群内部地址，外部是无法访问的。

3.4 创建deployment

3.4.1cat > yl-httpd-deployment.yml << “EOF”
apiVersion: apps/v1
kind: Deployment
metadata:
  name: yl-httpd
  namespace: yl-namespace
spec:
  replicas: 2
  selector:
    matchLabels:
     app: yl-httpd-dm
  revisionHistoryLimit: 5
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: yl-httpd-dm
    spec:
      terminationGracePeriodSeconds: 60
      restartPolicy: Always
      containers:
      - name: yl-httpd
        image: httpd:alpine
        imagePullPolicy: Always

注：在yl-httpd-deployment.yml这个文件中，我们在yl-namespace中，定义一个名为yl-httpd的Deployment，并且定义了一个yl-httpd-dm的labels。
   这样yl-httpd-svc这个Service就和yl-httpd这个Deployment关联起来了。
   同时在这个yml文件中，我们也定义了该pod的发布策略RollingUpdate滚动发布，以及副本集个数replicas: 2。
 
3.4.2 创建deploy
# kubectl apply -f yl-deploy.yaml
deployment.apps/yl-httpd created

3.4.3 查询创建的deploy
#kubectl get deploy -n yl-namespace -owide
NAME       READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES         SELECTOR
yl-httpd   2/2     2            2           11m   yl-httpd     httpd:alpine   app=yl-httpd-dm
查询对用的pod
# kubectl get pod -n yl-namespace -owide
NAME                        READY   STATUS    RESTARTS   AGE   IP              NODE    NOMINATED NODE   READINESS GATES
yl-httpd-5cb84fb46f-lt7kc   1/1     Running   0          11m   192.17.211.22   node4   <none>           <none>
yl-httpd-5cb84fb46f-vxbn6   1/1     Running   0          11m   192.26.28.5     node3   <none>           <none>

注：这里我们看到有两个yl-httpd pod运行在node4和node3节点，而且pod里面的IP地址也分别是192.17.211.22和192.26.28.5
这里面需要注意下每个pod所被分配的IP地址，是根据该pod所在node节点响应的网卡的IP地址段来分配的。

3.4.4 到node节点查看对外暴露的32080端口
#ssh node3
#netstat -tunlp|grep 32080
tcp        0      0 0.0.0.0:32080           0.0.0.0:*               LISTEN      11000/kube-proxy
注：我们可以很明显的看出node节点已经监听了我们在yl-httpd-service.yml文件中配置的yl-httpd-svc的NodePort对外的映射端口32080。

3.4.5 访问httpd服务
http://node3:32080
显示It works!

注：我们可以很明显的看出，yl-httpd-svc这个service已经正常对外提供服务，说明我们以上的操作都是正常的。

四、ingress配置实操
注意：service、deployment、ingress是区分namespace的。
ingress可以自动感知后端应用，这里就不需要查看httpd服务是在那个节点运行了。
